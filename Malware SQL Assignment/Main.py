import sys
import os
import codecs
from ParseTest import test

out = sys.stdout

def main(args):
    process_input_sql_files(args)
    print "Exiting..."

def process_input_sql_files (args):
    #check that a command line argument has been passed
    if (len(args) > 1):
        out.write('Directory of input SQL file appears to have been provided via Command Line Argument\n')
        testDirectory = args[1]
    else:
        out.write('No manual input directory specified, attempting to use default directory \n')
        testDirectory = os.getcwd() + os.sep + "TestData";
    
    #First import SQL queries to test
    validFiles = sanity_check(testDirectory)

    if (len(validFiles) > 0):
        selectionIndex = selectFile(validFiles)
        parse_filecontents(testDirectory + os.sep + validFiles[selectionIndex])
    else:
        print "Error importing test data"

    #Now input all files in the filter data directory
    filterDirectory = os.getcwd() + os.sep + "FilterData";
    validFiles = sanity_check(filterDirectory)

    if (len(validFiles) > 0):
        for index, value in enumerate(validFiles):
            print "Filter data file #" + str(index) + ": " + value

        if (query_yes_no("Okay to parse listed files?")):
            for file in validFiles:
                parse_filecontents(filterDirectory + os.sep + file)
        print "Aborting import..."
    else:
        print "Error importing filtering data"



def sanity_check(input_directory):
    validFiles = []

    print "Checking: " + input_directory
    if (os.path.exists(input_directory) and os.path.isdir(input_directory)):
        numberOfValidFiles = len([each for each in os.listdir(input_directory) if each.endswith('.sql') or each.endswith('.txt')])
        if (numberOfValidFiles <1):
            print "There must be at least 1 .txt or .sql file in the specified directory. This script can not find any."
            return validFiles;
        else:
            print str(numberOfValidFiles) + " valid input files found\n"
            for files in os.listdir(input_directory):
                if(files.endswith('.txt') or files.endswith('.sql')):
                    validFiles.append(files)
            return validFiles
    else:
        print "Invalid results directory specified"
        return validFiles;


def selectFile(validFiles):
    index = 1
    print '--------------------------'
    for x in range(0, len(validFiles)):
        print "ID: " + str(index) + ' | Name: ' + str(validFiles[x])
        index+=1
    print '--------------------------\n'

    if len(validFiles) == 1:
        print str(validFiles[0]) + " has been selected as it was the only valid file in the specified directory"
        selectionIndex = '1'
    else:
        selectionIndex = '-1'
        while not(selectionIndex.isdigit()) or int(selectionIndex) < 1 or int(selectionIndex) > len(validFiles): 
            selectionIndex = raw_input("Please enter ID of baseline file: ")

            if not(selectionIndex.isdigit()) and selectionIndex!='-1':
                print 'You can only enter a positive number!\n'
            elif int(selectionIndex) > len(validFiles):
                print 'Your selection has to be smaller than the ID of the last file!\n'

    return int(selectionIndex) - 1
    

def parse_filecontents(filename):
    f = codecs.open(filename, "r", "utf-8");
    readlines = f.readlines()
    from kitchen.text.converters import getwriter
    UTF8Writer = getwriter('utf8')
    sys.stdout = UTF8Writer(sys.stdout)

    for line in readlines:
        print line

def query_yes_no(question, default="yes"):

    validAnswers = {"yes": True, "y": True, "ye": True,
             "no": False, "n": False}
    if default is None:
        prompt = " [y/n] "
    elif default == "yes":
        prompt = " [Y/n] "
    elif default == "no":
        prompt = " [y/N] "
    else:
        raise ValueError("invalid default answer: '%s'" % default)

    while True:
        sys.stdout.write(question + prompt)
        choice = raw_input().lower()
        if default is not None and choice == '':
            return validAnswers[default]
        elif choice in validAnswers:
            return validAnswers[choice]
        else:
            sys.stdout.write("Please respond with 'yes' or 'no' "
                             "(or 'y' or 'n').\n")

if __name__ == "__main__":
    main(sys.argv)