import sys
import os
import codecs
import collections
import re
import time
from kitchen.text.converters import getwriter
from progressbar import ProgressBar, Percentage, Bar, Counter

out = sys.stdout

global testDataDict, whitelistData, blacklistDataDict, truePositive, trueNegative, falsePositive, falseNegative

def main(args):
    if not process_input_files(args):
        print "\nExiting due to error..."
    else:
        print "\nExiting normally..."

def process_input_files (args):
    global testData, whitelistData, blacklistDataDict, truePositive, trueNegative, falsePositive, falseNegative

    #check that a command line argument has been passed
    if (len(args) > 1):
        out.write('Directory of input SQL file appears to have been provided via Command Line Argument\n')
        testDirectory = args[1]
    else:
        out.write('No manual input directory specified, attempting to use default directory \n')
        testDirectory = os.getcwd() + os.sep + "TestData";
    
    #First import SQL queries to test
    validFiles = sanity_check(testDirectory, True)

    if (len(validFiles) > 0):
        selectionIndex = selectFile(validFiles)
        testDataDict = parse_files(testDirectory + os.sep + validFiles[selectionIndex], True)
    else:
        print "Error importing test data"
        return False

    #Decide on filtering method to use and input relevant files
    filterTypeAnswer = query_yes_no("\nPlease select which filtering method to use on input data:", True)

    filterDirectory = os.getcwd() + os.sep + "FilterData";
    whitelistlocation, blacklistlocation = sanity_check(filterDirectory, False, filterTypeAnswer)

    if filterTypeAnswer == "Whitelist":
        if whitelistlocation:
            whitelistData = parse_files(whitelistlocation, False)
        else:
            print "Whitelist file specified does not appear to be valid"
            return False

    if filterTypeAnswer == "Blacklist":
        if blacklistlocation:
            blacklistDataDict = parse_files(blacklistlocation, False)
            perform_analysis(testDataDict, blacklistDataDict)
        else:
            print "Blacklist file specified does not appear to be valid"
            return False

    return True

def perform_analysis (testData, filterData):
    truePositive = falsePositive = trueNegative = falseNegative = 0
    dictAllMatches = collections.OrderedDict()
    currentQuery = 0
    print "\nPerforming analysis"
    pbar = ProgressBar(widgets=[Percentage(), Bar(), ' Query: ', Counter(), '/', str(len(testData))], maxval=len(testData)).start()
    test = len(testData)
    #Cycle through testData and determine matches according to filterData
    for queryObject, queryType in testData.iteritems():
        matched = False
        matchingstrings = []
        currentQuery+= 1
        for filterObject, filterType in filterData.iteritems():
            #If value is s then this string should be used for string matching
            if filterType == 's':
                if filterObject.lower() in queryObject.lower():
                    matched = True
                    matchingstrings.append(filterObject)
            #If value is r then regex matching should be used
            elif filterType == 'r':
                if re.search(filterObject, queryObject, 34): #corresponds to unicode and ignore case
                    matched = True
                    matchingstrings.append(filterObject)

        dictAllMatches[queryObject] = matchingstrings
        if matched:
            if queryType == 'm':
                truePositive+=1
            else:
                falsePositive+=1
        else:
            if queryType == 'b':
                trueNegative+=1
            else:
                falseNegative+=1
        pbar.update(currentQuery)
    pbar.finish()
    print "\nTrue Positive: " + str(truePositive), "\tFalse Positive: " + str(falsePositive), "\tTrue Negative: " + str(trueNegative), "\tFalse Negative: " + str(falseNegative)


def sanity_check(input_directory, isTestData, filteringType="Whitelist"):
    validFiles = []
    whitelistLocation = None
    blacklistLocation = None

    if isTestData:
        print "\nChecking: " + input_directory + " for test data"
        if (os.path.exists(input_directory) and os.path.isdir(input_directory)):
            numberOfValidFiles = len([each for each in os.listdir(input_directory) if (each.endswith('.sql') or each.endswith('.txt')) and not os.stat(input_directory + os.sep + each).st_size==0])
            if (numberOfValidFiles <1):
                print "There must be at least 1 .txt or .sql file in the specified directory. This script can not find any."
                return validFiles;
            else:
                print str(numberOfValidFiles) + " valid input files found\n"
                for files in os.listdir(input_directory):
                    if((files.endswith('.txt') or files.endswith('.sql')) and not os.stat(input_directory + os.sep + files).st_size==0):
                        validFiles.append(files)
                return validFiles
        else:
            print "Invalid test data directory specified"
            return validFiles;
    else:
        print "\nChecking for " + filteringType + " in " + input_directory
        if (os.path.exists(input_directory) and os.path.isdir(input_directory)):
            for each in os.listdir(input_directory):
                if filteringType == "Both" or filteringType == "Whitelist":
                    if (each.endswith('.sql') or each.endswith('.txt')) and each[0:-4] == 'Whitelist' and not os.stat(input_directory + os.sep + each).st_size==0:
                        print "Whitelist appears valid.."
                        whitelistLocation = input_directory + os.sep + each

                if filteringType == "Both" or filteringType == "Blacklist":
                    if (each.endswith('.sql') or each.endswith('.txt')) and each[0:-4] == 'Blacklist' and not os.stat(input_directory + os.sep + each).st_size==0:
                        print "Blacklist appears valid.."
                        blacklistLocation = input_directory + os.sep + each
        else:
            print "Invalid filter data directory specified"

        return whitelistLocation, blacklistLocation


def selectFile(validFiles):
    index = 1
    print '---------------------------------------------------'
    for x in range(0, len(validFiles)):
        print "ID: " + str(index) + ' | Name: ' + str(validFiles[x])
        index+=1
    print '---------------------------------------------------\n'

    if len(validFiles) == 1:
        print str(validFiles[0]) + " has been selected as it was the only valid file in the specified directory"
        selectionIndex = '1'
    else:
        selectionIndex = '-1'
        while not(selectionIndex.isdigit()) or int(selectionIndex) < 1 or int(selectionIndex) > len(validFiles): 
            selectionIndex = raw_input("Please enter ID of input file: ")

            if not(selectionIndex.isdigit()) and selectionIndex!='-1':
                print 'You can only enter a positive number!\n'
            elif int(selectionIndex) > len(validFiles):
                print 'Your selection has to be smaller than the ID of the last file!\n'

    return int(selectionIndex) - 1
    
def parse_files(file, isTestData):
    tempDict = collections.OrderedDict()
    numDuplicates = 0
    numLines = 0
    with codecs.open(file, "r", "utf-8") as f:
        for line in f:
            line = ''.join(line.splitlines())
            line = line.replace(u'\u200b', '')
            line = line.replace(u'\ufeff', '')
            (val, key) = line.split(",", 1)

            if val != '#':
                if isTestData:
                    if re.search(r'\b(WHERE)\b', key, 34):
                        if key.split("WHERE", 1)[1].lstrip() not in tempDict:
                            tempDict[key.split("WHERE", 1)[1].lstrip()] = val
                        else:
                            numDuplicates += 1
                    else:
                        if key not in tempDict:
                            tempDict[key] = val
                        else:
                            numDuplicates += 1
                else:
                    if key not in tempDict:
                        tempDict[key] = val
                    else:
                        numDuplicates += 1
                numLines += 1

    print "\nSucessfully parsed " + str(numLines) + " lines but ignored " + str(numDuplicates) + " duplicate value(s)"
    return tempDict


def query_yes_no(question, whitelistBlackList, default="yes"):

    if not whitelistBlackList:
        validAnswers = {"yes": True, "y": True, "ye": True,
                 "no": False, "n": False}
        if default is None:
            prompt = " [y/n] "
        elif default == "yes":
            prompt = " [Y/n] "
        elif default == "no":
            prompt = " [y/N] "
        else:
            raise ValueError("invalid default answer: '%s'" % default)
    else:
        validAnswers = {"1": "Whitelist", "2": "Blacklist"}
        default = "1"

        prompt = "\n1 = Whitelist Only\n2 = Blacklist Only\nDefault = Whitelist Only\n"

    while True:
        sys.stdout.write(question + prompt)
        choice = raw_input().lower()
        if default is not None and choice == '':
            return validAnswers[default]
        elif choice in validAnswers:
            return validAnswers[choice]
        else:
            sys.stdout.write("Please respond with one of: ")
            for answer in validAnswers:
                sys.stdout.write(answer + ", ")
            print("")

if __name__ == "__main__":
    main(sys.argv)